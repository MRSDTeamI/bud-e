/* Auto-generated by genmsg_cpp for file /home/gautam/hearbo_2dnav/hearbo_cart_ts/hearbo_cart_msgs/msg/CartCommand.msg */
#ifndef HEARBO_CART_MSGS_MESSAGE_CARTCOMMAND_H
#define HEARBO_CART_MSGS_MESSAGE_CARTCOMMAND_H
#include <string>
#include <vector>
#include <map>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/time.h"

#include "ros/macros.h"

#include "ros/assert.h"


namespace hearbo_cart_msgs
{
template <class ContainerAllocator>
struct CartCommand_ {
  typedef CartCommand_<ContainerAllocator> Type;

  CartCommand_()
  : drive_flag(0)
  , gain_flag(0)
  , encoder_flag(0)
  , drive_mode(0)
  , drive_id()
  , each_vel()
  , each_ang()
  , all_vel(0.0)
  , all_ang(0.0)
  , gain_id_ch0()
  , gain_id_ch1()
  , gain_ch0()
  , gain_ch1()
  , encoder_id_ch0()
  , encoder_id_ch1()
  , encoder_ch0()
  , encoder_ch1()
  {
    drive_id.assign(0);
    each_vel.assign(0.0);
    each_ang.assign(0.0);
    gain_id_ch0.assign(0);
    gain_id_ch1.assign(0);
    gain_ch0.assign(0);
    gain_ch1.assign(0);
    encoder_id_ch0.assign(0);
    encoder_id_ch1.assign(0);
    encoder_ch0.assign(0);
    encoder_ch1.assign(0);
  }

  CartCommand_(const ContainerAllocator& _alloc)
  : drive_flag(0)
  , gain_flag(0)
  , encoder_flag(0)
  , drive_mode(0)
  , drive_id()
  , each_vel()
  , each_ang()
  , all_vel(0.0)
  , all_ang(0.0)
  , gain_id_ch0()
  , gain_id_ch1()
  , gain_ch0()
  , gain_ch1()
  , encoder_id_ch0()
  , encoder_id_ch1()
  , encoder_ch0()
  , encoder_ch1()
  {
    drive_id.assign(0);
    each_vel.assign(0.0);
    each_ang.assign(0.0);
    gain_id_ch0.assign(0);
    gain_id_ch1.assign(0);
    gain_ch0.assign(0);
    gain_ch1.assign(0);
    encoder_id_ch0.assign(0);
    encoder_id_ch1.assign(0);
    encoder_ch0.assign(0);
    encoder_ch1.assign(0);
  }

  typedef uint8_t _drive_flag_type;
  uint8_t drive_flag;

  typedef uint8_t _gain_flag_type;
  uint8_t gain_flag;

  typedef uint8_t _encoder_flag_type;
  uint8_t encoder_flag;

  typedef uint8_t _drive_mode_type;
  uint8_t drive_mode;

  typedef boost::array<uint8_t, 4>  _drive_id_type;
  boost::array<uint8_t, 4>  drive_id;

  typedef boost::array<float, 4>  _each_vel_type;
  boost::array<float, 4>  each_vel;

  typedef boost::array<float, 4>  _each_ang_type;
  boost::array<float, 4>  each_ang;

  typedef float _all_vel_type;
  float all_vel;

  typedef float _all_ang_type;
  float all_ang;

  typedef boost::array<uint8_t, 4>  _gain_id_ch0_type;
  boost::array<uint8_t, 4>  gain_id_ch0;

  typedef boost::array<uint8_t, 4>  _gain_id_ch1_type;
  boost::array<uint8_t, 4>  gain_id_ch1;

  typedef boost::array<int16_t, 4>  _gain_ch0_type;
  boost::array<int16_t, 4>  gain_ch0;

  typedef boost::array<int16_t, 4>  _gain_ch1_type;
  boost::array<int16_t, 4>  gain_ch1;

  typedef boost::array<uint8_t, 4>  _encoder_id_ch0_type;
  boost::array<uint8_t, 4>  encoder_id_ch0;

  typedef boost::array<uint8_t, 4>  _encoder_id_ch1_type;
  boost::array<uint8_t, 4>  encoder_id_ch1;

  typedef boost::array<int32_t, 4>  _encoder_ch0_type;
  boost::array<int32_t, 4>  encoder_ch0;

  typedef boost::array<int32_t, 4>  _encoder_ch1_type;
  boost::array<int32_t, 4>  encoder_ch1;

  enum { FALSE = 0 };
  enum { TRUE = 1 };
  enum { STOP_MODE = 0 };
  enum { TURN_MODE = 1 };
  enum { DRIVE_MODE = 2 };
  enum { MANUAL_MODE = 3 };
  enum { RESTART_MODE = 4 };

  typedef boost::shared_ptr< ::hearbo_cart_msgs::CartCommand_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::hearbo_cart_msgs::CartCommand_<ContainerAllocator>  const> ConstPtr;
  boost::shared_ptr<std::map<std::string, std::string> > __connection_header;
}; // struct CartCommand
typedef  ::hearbo_cart_msgs::CartCommand_<std::allocator<void> > CartCommand;

typedef boost::shared_ptr< ::hearbo_cart_msgs::CartCommand> CartCommandPtr;
typedef boost::shared_ptr< ::hearbo_cart_msgs::CartCommand const> CartCommandConstPtr;


template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const  ::hearbo_cart_msgs::CartCommand_<ContainerAllocator> & v)
{
  ros::message_operations::Printer< ::hearbo_cart_msgs::CartCommand_<ContainerAllocator> >::stream(s, "", v);
  return s;}

} // namespace hearbo_cart_msgs

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::hearbo_cart_msgs::CartCommand_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::hearbo_cart_msgs::CartCommand_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::hearbo_cart_msgs::CartCommand_<ContainerAllocator> > {
  static const char* value() 
  {
    return "59937212c7ecdba57a473a75da70fa95";
  }

  static const char* value(const  ::hearbo_cart_msgs::CartCommand_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0x59937212c7ecdba5ULL;
  static const uint64_t static_value2 = 0x7a473a75da70fa95ULL;
};

template<class ContainerAllocator>
struct DataType< ::hearbo_cart_msgs::CartCommand_<ContainerAllocator> > {
  static const char* value() 
  {
    return "hearbo_cart_msgs/CartCommand";
  }

  static const char* value(const  ::hearbo_cart_msgs::CartCommand_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::hearbo_cart_msgs::CartCommand_<ContainerAllocator> > {
  static const char* value() 
  {
    return "#\n\
# iXs cart control message\n\
#\n\
\n\
#\n\
# Some pre-defined parameters\n\
#\n\
\n\
uint8 FALSE=0\n\
uint8 TRUE=1\n\
\n\
# ====================================================================================\n\
# Message structure setting\n\
# ====================================================================================\n\
\n\
#\n\
# valid : \n\
# \n\
# Major selection of message structure sent to the robot.\n\
# You can set the following three commands valid/invalid.\n\
# (1) Commands for drive (steering angle, velocity of driving wheels, selection of free/driven motors)\n\
# (2) Gain of each motor\n\
# (3) Motor selection for encoder value reset\n\
# Those three settings do not have to be sent to the robot simultaneously.\n\
#\n\
# Example1\n\
# If you want to only change the gain, set \"gain_flag\" TRUE.\n\
#\n\
# Example2\n\
# If you want to change both velocity and gain of the motors, set \"gain_flag\" and \"drive_flag\" TRUE. \n\
# \n\
\n\
uint8 drive_flag\n\
uint8 gain_flag\n\
uint8 encoder_flag\n\
\n\
# ====================================================================================\n\
# Message when drive_flag is TRUE\n\
# ====================================================================================\n\
\n\
#\n\
# drive_mode : cart control mode\n\
#\n\
# STOP_MODE : \n\
# This set all the gain zero (Encoder is not reset)\n\
#\n\
# TURN_MODE : \n\
# Spin rotation mode (Desired encoder values of steering motors is fixed for spinning)\n\
#\n\
# DRIVE_MODE : \n\
# Steering syncronization mode (Desired encoder values of steering motors are set to be the same.)\n\
#\n\
# MANUAL_MODE :\n\
# You can set the following things freely for each motor.\n\
# (1) Angle of steering motors, (3) Velocity of driving wheels\n\
#\n\
# RESTART_MODE : \n\
# This set all the gain default values (Encoder is not reset)\n\
#\n\
\n\
uint8 drive_mode\n\
uint8 STOP_MODE=0\n\
uint8 TURN_MODE=1\n\
uint8 DRIVE_MODE=2\n\
uint8 MANUAL_MODE=3\n\
uint8 RESTART_MODE=4\n\
\n\
#\n\
# drive_id : selection of motor id (This decides which motor is processed/unprocessed.)\n\
# ID0 : Left  front wheel \n\
# ID1 : Left  back  wheel \n\
# ID2 : Right back wheel \n\
# ID3 : Right front wheel \n\
# This setting is valid when the \"drive_mode\" is TURN_MODE/DRIVE_MODE/MANUAL_MODE.\n\
# \n\
# Set each element of \"drive_id\" TRUE for activation and FALSE for deactivation.\n\
# drive_id[0] : Left  front wheel \n\
# drive_id[1] : Left  back  wheel \n\
# drive_id[2] : Right back wheel \n\
# drive_id[3] : Right front wheel \n\
# If you set FALSE for some axes, the motors of the axes will be deactivated (free motors). \n\
#\n\
\n\
uint8[4] drive_id\n\
\n\
#\n\
# each_vel : desired velocity of each drive wheel\n\
# This setting is valid when the \"drive_mode\" is MANUAL_MODE.\n\
# \n\
# Set each element of \"each_vel\" as the desired velocity [mm/s].\n\
# each_vel[0] : Left  front wheel \n\
# each_vel[1] : Left  back  wheel \n\
# each_vel[2] : Right back wheel \n\
# each_vel[3] : Right front wheel \n\
#\n\
\n\
float32[4] each_vel\n\
\n\
#\n\
# each_ang : desired angle of each steering motor\n\
# This setting is valid when the \"drive_mode\" is MANUAL_MODE.\n\
# \n\
# Set each element of \"each_ang\" as the desired angle [deg].\n\
# each_ang[0] : Left  front wheel \n\
# each_ang[1] : Left  back  wheel \n\
# each_ang[2] : Right back wheel \n\
# each_ang[3] : Right front wheel \n\
#\n\
\n\
float32[4] each_ang\n\
\n\
#\n\
# all_vel : desired velocity of all drive wheels\n\
# This setting is valid when the \"drive_mode\" is TURN_MODE/DRIVE_MODE.\n\
# \n\
# Set \"all_vel\" as the desired velocity [mm/s].\n\
# Then the desired velocities of all driving wheels are set. \n\
#\n\
\n\
float32 all_vel\n\
\n\
#\n\
# all_ang : desired angle of all steering motors\n\
# This setting is valid when the \"drive_mode\" is DRIVE_MODE.\n\
# \n\
# Set \"all_ang\" as the desired angle [deg].\n\
# Then the desired angles of all steering motors are set. \n\
#\n\
\n\
float32 all_ang\n\
\n\
# ====================================================================================\n\
# Message when gain_flag is TRUE\n\
# ====================================================================================\n\
\n\
#\n\
# gain_id_ch : selection of motor id (This decides which gain is set/ignored.)\n\
# \n\
# Set each element of \"gain_id_ch0\" and \"gain_id_ch1\" TRUE for activation and FALSE for deactivation.\n\
# gain_id_ch0[0] : Left  front driving wheel \n\
# gain_id_ch0[1] : Left  back  driving wheel \n\
# gain_id_ch0[2] : Right back  driving wheel \n\
# gain_id_ch0[3] : Right front driving wheel \n\
# gain_id_ch1[0] : Left  front steering motor \n\
# gain_id_ch1[1] : Left  back  steering motor \n\
# gain_id_ch1[2] : Right back  steering motor \n\
# gain_id_ch1[3] : Right front steering motor \n\
#\n\
\n\
uint8[4] gain_id_ch0\n\
uint8[4] gain_id_ch1\n\
\n\
#\n\
# gain_ch : propotional gain setting for each motor (P control)\n\
# \n\
# Set each element of \"gain_ch\" as the desired propotional gain.\n\
# gain_ch0[0] : Left  front driving wheel \n\
# gain_ch0[1] : Left  back  driving wheel \n\
# gain_ch0[2] : Right back  driving wheel \n\
# gain_ch0[3] : Right front driving wheel \n\
# gain_ch1[0] : Left  front steering motor \n\
# gain_ch1[1] : Left  back  steering motor \n\
# gain_ch1[2] : Right back  steering motor \n\
# gain_ch1[3] : Right front steering motor \n\
#\n\
\n\
int16[4] gain_ch0\n\
int16[4] gain_ch1\n\
\n\
# ====================================================================================\n\
# Message when encoder_flag is TRUE\n\
# ====================================================================================\n\
\n\
#\n\
# encoder_id_ch : selection of motor id (This decides which motor encoder is reset.)\n\
# \n\
# Set each element of \"encoder_id_ch0\" and \"encoder_id_ch1\" TRUE for activation and FALSE for deactivation.\n\
# encoder_id_ch0[0] : Left  front driving wheel \n\
# encoder_id_ch0[1] : Left  back  driving wheel \n\
# encoder_id_ch0[2] : Right back  driving wheel \n\
# encoder_id_ch0[3] : Right front driving wheel \n\
# encoder_id_ch1[0] : Left  front steering motor \n\
# encoder_id_ch1[1] : Left  back  steering motor \n\
# encoder_id_ch1[2] : Right back  steering motor \n\
# encoder_id_ch1[3] : Right front steering motor \n\
#\n\
\n\
uint8[4] encoder_id_ch0\n\
uint8[4] encoder_id_ch1\n\
\n\
#\n\
# encoder_ch : encoder reset value setting for each motor\n\
# \n\
# Set each element of \"encoder_ch\" as the encoder value after reset.\n\
# encoder_ch0[0] : Left  front driving wheel \n\
# encoder_ch0[1] : Left  back  driving wheel \n\
# encoder_ch0[2] : Right back  driving wheel \n\
# encoder_ch0[3] : Right front driving wheel \n\
# encoder_ch1[0] : Left  front steering motor \n\
# encoder_ch1[1] : Left  back  steering motor \n\
# encoder_ch1[2] : Right back  steering motor \n\
# encoder_ch1[3] : Right front steering motor \n\
#\n\
\n\
int32[4] encoder_ch0\n\
int32[4] encoder_ch1\n\
\n\
\n\
";
  }

  static const char* value(const  ::hearbo_cart_msgs::CartCommand_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator> struct IsFixedSize< ::hearbo_cart_msgs::CartCommand_<ContainerAllocator> > : public TrueType {};
} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::hearbo_cart_msgs::CartCommand_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.drive_flag);
    stream.next(m.gain_flag);
    stream.next(m.encoder_flag);
    stream.next(m.drive_mode);
    stream.next(m.drive_id);
    stream.next(m.each_vel);
    stream.next(m.each_ang);
    stream.next(m.all_vel);
    stream.next(m.all_ang);
    stream.next(m.gain_id_ch0);
    stream.next(m.gain_id_ch1);
    stream.next(m.gain_ch0);
    stream.next(m.gain_ch1);
    stream.next(m.encoder_id_ch0);
    stream.next(m.encoder_id_ch1);
    stream.next(m.encoder_ch0);
    stream.next(m.encoder_ch1);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct CartCommand_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::hearbo_cart_msgs::CartCommand_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const  ::hearbo_cart_msgs::CartCommand_<ContainerAllocator> & v) 
  {
    s << indent << "drive_flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.drive_flag);
    s << indent << "gain_flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.gain_flag);
    s << indent << "encoder_flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.encoder_flag);
    s << indent << "drive_mode: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.drive_mode);
    s << indent << "drive_id[]" << std::endl;
    for (size_t i = 0; i < v.drive_id.size(); ++i)
    {
      s << indent << "  drive_id[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.drive_id[i]);
    }
    s << indent << "each_vel[]" << std::endl;
    for (size_t i = 0; i < v.each_vel.size(); ++i)
    {
      s << indent << "  each_vel[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.each_vel[i]);
    }
    s << indent << "each_ang[]" << std::endl;
    for (size_t i = 0; i < v.each_ang.size(); ++i)
    {
      s << indent << "  each_ang[" << i << "]: ";
      Printer<float>::stream(s, indent + "  ", v.each_ang[i]);
    }
    s << indent << "all_vel: ";
    Printer<float>::stream(s, indent + "  ", v.all_vel);
    s << indent << "all_ang: ";
    Printer<float>::stream(s, indent + "  ", v.all_ang);
    s << indent << "gain_id_ch0[]" << std::endl;
    for (size_t i = 0; i < v.gain_id_ch0.size(); ++i)
    {
      s << indent << "  gain_id_ch0[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.gain_id_ch0[i]);
    }
    s << indent << "gain_id_ch1[]" << std::endl;
    for (size_t i = 0; i < v.gain_id_ch1.size(); ++i)
    {
      s << indent << "  gain_id_ch1[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.gain_id_ch1[i]);
    }
    s << indent << "gain_ch0[]" << std::endl;
    for (size_t i = 0; i < v.gain_ch0.size(); ++i)
    {
      s << indent << "  gain_ch0[" << i << "]: ";
      Printer<int16_t>::stream(s, indent + "  ", v.gain_ch0[i]);
    }
    s << indent << "gain_ch1[]" << std::endl;
    for (size_t i = 0; i < v.gain_ch1.size(); ++i)
    {
      s << indent << "  gain_ch1[" << i << "]: ";
      Printer<int16_t>::stream(s, indent + "  ", v.gain_ch1[i]);
    }
    s << indent << "encoder_id_ch0[]" << std::endl;
    for (size_t i = 0; i < v.encoder_id_ch0.size(); ++i)
    {
      s << indent << "  encoder_id_ch0[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.encoder_id_ch0[i]);
    }
    s << indent << "encoder_id_ch1[]" << std::endl;
    for (size_t i = 0; i < v.encoder_id_ch1.size(); ++i)
    {
      s << indent << "  encoder_id_ch1[" << i << "]: ";
      Printer<uint8_t>::stream(s, indent + "  ", v.encoder_id_ch1[i]);
    }
    s << indent << "encoder_ch0[]" << std::endl;
    for (size_t i = 0; i < v.encoder_ch0.size(); ++i)
    {
      s << indent << "  encoder_ch0[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.encoder_ch0[i]);
    }
    s << indent << "encoder_ch1[]" << std::endl;
    for (size_t i = 0; i < v.encoder_ch1.size(); ++i)
    {
      s << indent << "  encoder_ch1[" << i << "]: ";
      Printer<int32_t>::stream(s, indent + "  ", v.encoder_ch1[i]);
    }
  }
};


} // namespace message_operations
} // namespace ros

#endif // HEARBO_CART_MSGS_MESSAGE_CARTCOMMAND_H

